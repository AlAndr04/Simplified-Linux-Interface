// **********************************************************
// Assignment2:
// Student1: Abhinav Chaudharu
// UTORID username: chaud349
// UT Student #: 1002707733
// Author: Abhinav Chaudhary
//
// Student2: Alexandru Andros
// UTORID username: androsal
// UT Student #:
// Author: Alexandru Andros
//
// Student3: Balaji Babu
// UTORID username: babubala
// UT Student #:1003354871
// Author: Balaji Babu
//
// Student4: Zhi Zhong Huang
// UTORID username: huang472
// UT Student #:1002671094
// Author: Zhi Zhong Huang
//
//
// Honor Code: I pledge that this program represents my own
// program code and that I have coded on my own. I received
// help from no one in designing and debugging my program.
// I have also read the plagiarism section in the course info
// sheet of CSC B07 and understand the consequences.
// *********************************************************
package dirCommands;

import fileSystemObjects.*;
import driver.JShell;
import input.Output;
import input.PathIncorrectException;
import input.UniqueNameException;
import java.util.ArrayList;
import java.util.Arrays;

/***
 * Class meant to represent the ls shell command. Has responsibility to output
 * the names of the current contents of the current directory or other
 * directories specified by either their absolute or relative paths.
 *
 */
public class Ls extends Commands<String> {
  /***
   * String containing the absolute or relative paths of the directories wanted
   * their contents to be listed.
   */
  String[] lsTarget;
  boolean recursion;

  /***
   * Constructor for a Ls object, setting the values of lsTarget to path.
   * 
   * @param paths Paths of the directories which contents are wanting to be
   *        displayed
   */
/*  public Ls(String[] paths) {
    this.lsTarget = paths;
  }*/
  
  public Ls(String[] paths, boolean option) {
    this.lsTarget = paths;
    this.recursion = option;
  }
  
//  public static void main(String[] args) {
//    try {
//      Directory rootDir = new Directory("/");
//      Directory onelevelOne = Directory.makeDir("Dir_1", rootDir);
//        Directory.makeDir("Dir_1_1", onelevelOne);
//        File oneFileLevelTwo = new File("file_1_1", onelevelOne);
//        Directory.makeDir("Dir_1_2", onelevelOne);
//      Directory twolevelOne = Directory.makeDir("Dir_2", rootDir);
//      Directory threelevelOne = Directory.makeDir("Dir_3", rootDir);
//      Directory fourlevelOne = Directory.makeDir("Dir_4", rootDir);
//      Directory fivelevelOne = Directory.makeDir("Dir_5", rootDir);
//        Directory.makeDir("Dir_5_1", fivelevelOne);
//        File fiveFileLevelTwo = new File("file_5_1", fivelevelOne);
//        Directory.makeDir("Dir_5_2", fivelevelOne);
//      Tree newTree = new Tree();
//      System.out.println(newTree.buildTree(rootDir, 0));
//    } catch (UniqueNameException e) {
//      System.out.println("This shouldn't be reached.");
//    }
//    String[] newString = {"/","Dir_1"};
//    Ls dog = new Ls(newString,true);
//    ArrayList<FSElement> newFS = new ArrayList<FSElement>();
//    try {
//      System.out.println(list(subDirAccu(Traverse.returnGivenPathFromRoot(dog.lsTarget), 
//          newFS)));
//    } catch (PathIncorrectException e) {
//      e.printStackTrace();
//    }
//  }
  
  private String executeHelper() {
    String output = "";
    if (lsTarget.length == 0) {
      try {
        output = list(JShell.currdir);
      } catch (NullPointerException e) {
        Output.commandInvalid();
      }
    } else {
      output = "";
      ArrayList<FSElement> allinput = new ArrayList<FSElement>();
      for (int i = 0; i < lsTarget.length; i++) {
        FSElement temp = Traverse.accessFS(lsTarget[i], JShell.root);
        if (temp != null) {
          allinput.add(temp);
        } else {
          Output.pathDoesNotExistError(lsTarget[i]);
        }
      }
      output = Ls.list(allinput);
    }
    return output;
  }
  /***
   * Executes the function by calling list method.
   */
  public String execute() {
    if (recursion) {
      ArrayList<FSElement> newArr =  new ArrayList<FSElement>();
      try {
        String ret;
        if (lsTarget.length == 0) {
          ret = list(subDirAccu(JShell.currdir,newArr));
        } else {
          if (Traverse.returnGivenPathFromRoot(lsTarget) instanceof Directory) {
            ret = list(subDirAccu(Traverse.returnGivenPathFromRoot(lsTarget), 
            newArr));
          } else {
            ret = list(Traverse.returnGivenPathFromRoot(lsTarget));
          }
        }
          return ret;
        } catch (PathIncorrectException e) {
          Output.pathIncorrect(e.toString());
          return null;
        }
      } else {
        return executeHelper();
      }
    }

  /***
   * Returns a string of the names of the children of a directory given as a
   * parameter, with whitespace separating the names of the children.
   * 
   * @param element Directory element wanting the contents of it to be returned
   *        as a string
   * @return string which represents the contents of the directory element
   *         parameter
   * @throws NotDirectoryExceDirectoryptDirectoryion Thrown when a file is 
   *         placed as a parameter
   * @throws NullPointerException Thrown when a null is given as a parameter
   */
  private static String list(FSElement element)
      throws NullPointerException {
    if (element instanceof File) {
      return ((File) element).getContent();
    } else {
      String toReturn = "";
      if (!(((Directory)element).getChildDir().isEmpty())) {
        for (int i = 0; i < ((Directory)element).getChildDir().size(); i++) {
          toReturn += ((Directory)element).getChildDir().get(i).getName() + 
              "\n";
        }
      }
      return toReturn.trim();
    }
  }
  
  private static ArrayList<FSElement> subDirAccu(FSElement element, 
      ArrayList<FSElement> toReturn) {
    ArrayList<FSElement> ret = toReturn;
    ret.add(element);
    if (element instanceof Directory) {
      for (FSElement E: ((Directory)element).getChildDir()) {
        ret = subDirAccu(E,ret);
      }
    }
    return ret;
  }

  /***
   * Returns a string with the names of the children of the directories in the
   * elements array, with the name of the directory and its children separated
   * by a colon and a newline character.
   * 
   * @param elements Array of Directory elements whose names of children are
   *        wanting to be displayed.
   * @return String formatted as mentioned in method description
   */
  private static String list(ArrayList<FSElement> elements) {
    String toReturnLs = "";
    FSElement E;
    for (int i = 0; i < elements.size(); i++) {
      try {
        E = elements.get(i);
        if (E instanceof File) {
          toReturnLs += list(E)+"\n";
        } else {
          toReturnLs += (E.getName() + ":\n" + Ls.list(E));
          if (i != elements.size() - 1) {
            toReturnLs += "\n\n";
          }
        }
      } catch (NullPointerException e) {
        Output.commandInvalid();
      }
    }
    return toReturnLs;
  }
}
