// **********************************************************
// Assignment2:
// Student1: Abhinav Chaudharu
// UTORID username: chaud349
// UT Student #: 1002707733
// Author: Abhinav Chaudhary
//
// Student2: Alexandru Andros
// UTORID username: androsal
// UT Student #: 1004354263
// Author: Alexandru Andros
//
// Student3: Balaji Babu
// UTORID username: babubala
// UT Student #:1003354871
// Author: Balaji Babu
//
// Student4: Zhi Zhong Huang
// UTORID username: huang472
// UT Student #:1002671094
// Author: Zhi Zhong Huang
//
//
// Honor Code: I pledge that this program represents my own
// program code and that I have coded on my own. I received
// help from no one in designing and debugging my program.
// I have also read the plagiarism section in the course info
// sheet of CSC B07 and understand the consequences.
// *********************************************************
package fileCommands;

import java.lang.reflect.Array;
import java.util.Arrays;
import dirCommands.*;
import dirCommands.Traverse;
import driver.JShell;
import fileSystemObjects.Directory;
import fileSystemObjects.File;
import input.Output;
import input.Parse;
import input.PathIncorrectException;
import input.UniqueNameException;

public class Echo extends Commands<Void> {
  // Initiallizing Variables
  private int size;
  private String content;
  private String fileAndOperator;
  private boolean appendFile = false;
  private boolean newFile = false;

  /**
   * Constructor for object Echo (Command Echo). Takes Input and breaks it into
   * substring .
   * 
   * @param input: Array String
   * @return None
   */
  public Echo(String[] input) {
    // Getting the size of the echo command
    this.size = input.length;
    // Case 1 : When >>echo "I love Apples"
    if (size == 1) {
      this.content = input[0];
    }
    // Case 2 : When :-> echo "I love Apples" > apples.txt
    // Case 3 : When :-> echo "but I like mangoes too" >> apples.txt
    if (size == 2) {
      // "I love Apples"
      this.content = input[0];
      // ">apples.txt"
      this.fileAndOperator = input[1];
      // Taking care of Case 3 here
      if (fileAndOperator.contains(">>")) {
        this.appendFile = true;
        // ">> apples.txt"
        this.fileAndOperator = this.fileAndOperator.replaceAll(">>", "");
        this.fileAndOperator = this.fileAndOperator.replaceAll("\\s+", "");
      }
      // Taking care of Case 2 here
      else if (fileAndOperator.contains(">")) {
        this.newFile = true;
        // "> apples.txt"
        this.fileAndOperator = this.fileAndOperator.replaceAll(">", "");
        this.fileAndOperator = this.fileAndOperator.replaceAll("\\s+", "");
      } else {
        Output.invalidInput();
      }
    }
  }

  /**
   * Executes the cat command, with already given file(s) parameter(s)
   * 
   * @param None
   * @return None
   */
  public Void execute() {
	String[][] pathArray;
	String[] currPathArray = null;
	String[] currPathMk = null;
    if (size == 1) {
      Output.printTextToShell(content);
      }
	if (size == 2) {
		if(this.fileAndOperator.contains("/")) {
			String[][] arr = absoluteFile(this.fileAndOperator);
			currPathArray = arr[0];
			currPathMk = arr[1];
			this.fileAndOperator = currPathArray[(currPathArray.length)-1];
		}
		else {
			pathArray = currPathArr();
			currPathArray = pathArray[0];
			currPathMk = pathArray[1];
		}
      }
        if (newFile) {
        	try {
				newfile(currPathArray, currPathMk);
			} catch (PathIncorrectException e) {
		        Output.pathIncorrect(e.toString());
			}
        }
        if (appendFile) {
        	appendfile(currPathArray);
      }
    return null;
  }
  /**
   * This is when the user gives in a relative path 
   * this helper method finds the current working
   * directory and makes currPathArray and currPathMk
   * EXAMPLE: 
   * >>> mkdir User User/Abhinav User/Abhinav/Doc
   * >>> cd User/Abhinav/Doc
   * >>> echo "Make me a file machine" > file.txt
   * The method would do the following
   * currPathArray -> [/, User, Abhinav, Doc, file.txt]
   * currPathMk -> [/, User, Abhinav, Doc]
   * 
   * @param None
   * @return String[][]
   */
  public String[][] currPathArr() {
	// Getting the path is a string form eg : "/Abhi/Document/B07/"
      String currPath = Pwd.returnPathFromRoot(JShell.currdir);
      String currPathStringMk =
          "*/" + currPath.substring(1, currPath.length());
      String currPathString =
          "*/" + currPath.substring(1, currPath.length()) + "/"
              + fileAndOperator;
      // Changing the path string into an array [ ,Abhi,Document,B07]
      String[] currPathArray = currPathString.split("/");
      String[] currPathMk = currPathStringMk.split("/");
      // Add the root in the array [ / , Abhi, Document, B07]
      currPathArray[0] = "/";
      currPathMk[0] = "/";
      if (currPath.equals("/")) {
        currPathArray = new String[2];
        currPathArray[0] = "/";
        currPathArray[1] = fileAndOperator;
      }
      String[][] retArr = {currPathArray, currPathMk};
	return retArr;
  }
  /**
   * This helper method creates a new file or if the file
   * already exist it deletes the content of the file and
   * appends the new content given by the user
   * existing file.
   * Example :
   * 	newfile([/, User, Abhinav, Doc, file.txt] ,
   * 								 [/, User, Abhinav, Doc])
   * @param String[], String[]
   * @return void
   */
  public void newfile(String[] currPathArray, String[] currPathMk) 
		  throws PathIncorrectException {
	  if (Traverse.returnGivenPathFromRootFile(currPathArray) == null) {
	      Mkfile file = new Mkfile(currPathMk);
	      File fileMade;
	      try {
	        fileMade = file.mkFileWPath(fileAndOperator);
	        fileMade.addToContent(content);
	      } catch (PathIncorrectException e) {
	        Output.pathIncorrect(e.toString());
	      } catch (UniqueNameException e) {
	        Output.nameNotValid(e.toString());
	      }
	      // Appending the contents of the file to the the node...
    } else {
	      // Find the path of the file
	      File foundfile =
	          Traverse.returnGivenPathFromRootFile(currPathArray);
	      // Delete the contents of the file
	      foundfile.delStrings();
	      // Add the content
	      foundfile.addToContent(content);
	  
  }
}
  /**
   * This helper method appends content to an already
   * existing file.
   * Example :
   * 	appndfile([/, User, Abhinav, Doc, file.txt])
   * @param String[]
   * @return void
   */
  public void appendfile(String[] currPathArray){   
	 try {
	// Find the path of the file
      File foundFile =
          Traverse.returnGivenPathFromRootFile(currPathArray);
      // Add the contents
      content = "\n" + content;
      foundFile.addToContent(content);
    }
   catch (PathIncorrectException e) {
    Output.pathIncorrect(e.toString());
   		}
  }
  /**
   * This is when the user gives in a absolute path 
   * this helper method finds the current working
   * directory and makes currPathArray and currPathMk
   * EXAMPLE: 
   * >>> mkdir User /User/Abhinav /User/Abhinav/Doc
   * >>> echo "Make me a file machine" > 
   * 							/User/Abhinav/Doc/file.txt
   * The method would do the following
   * currPathArray -> [/, User, Abhinav, Doc, file.txt]
   * currPathMk -> [/, User, Abhinav, Doc]
   * 
   * @param None
   * @return String[][]
   */
  public String[][] absoluteFile(String file) {
	  // Split the contents of the path into an array
	  String[] fileArr = file.split("/"); 
	  int lastElement = (fileArr.length)-1;
	  String[] currPathMk = Arrays.copyOfRange(fileArr, 0, lastElement);
	  currPathMk[0] = "/";
	  String[] currPathArray = fileArr;
	  currPathArray[0] = "/";
	  // Return a 2D array
      String[][] retVal = {currPathArray, currPathMk};
	return(retVal);
  }
}

