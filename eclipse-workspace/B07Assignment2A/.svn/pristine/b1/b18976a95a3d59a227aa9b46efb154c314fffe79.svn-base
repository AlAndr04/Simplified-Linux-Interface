package test;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import dirCommands.Traverse;
import input.PathIncorrectException;

public class TraverseTest {
  private MockJShell mockJS;

  @Before
  public void setUp() {
    mockJS = new MockJShell();
  }

  @Test
  public void testReturnRoot() {
    mockJS.moveCurrDirOneLevelOne();
    assertEquals(mockJS.getRootDir(),
        Traverse.returnRoot(mockJS.getMockLocation().getCurrDir()));
  }

  @Test
  public void testReturnGivenPathFromRootFile() throws PathIncorrectException {
    mockJS.moveCurrDirOneLevelOne();
    String[] newPath = {"/", "Dir_1"};
    assertEquals(mockJS.getMockLocation().getCurrDir(),
        Traverse.returnGivenPathFromRoot(newPath, mockJS.getRootDir()));
  }

  @Test(expected = PathIncorrectException.class)
  public void testReturnGivenPathFromRootFileIncorrect()
      throws PathIncorrectException {
    mockJS.moveCurrDirOneLevelOne();
    String[] newPath = {"/", "Dir_Non_Existant"};
    Traverse.returnGivenPathFromRoot(newPath, mockJS.getRootDir());
  }

  @Test
  public void testreturnGivenPathFromRootFile() throws PathIncorrectException {
    mockJS.moveCurrDirOneLevelOne();
    String[] newPath = {"/", "Dir_1", "file_1_1"};
    assertEquals(mockJS.returnFileRef(),
        Traverse.returnGivenPathFromRootFile(newPath, mockJS.getRootDir()));
  }

  @Test
  public void testreturnGivenPathFromRootFileIncorrect()
      throws PathIncorrectException {
    String[] newPath = {"/", "Dir_1", "huh?"};
    assertEquals(null,
        Traverse.returnGivenPathFromRootFile(newPath, mockJS.getRootDir()));
  }
}
